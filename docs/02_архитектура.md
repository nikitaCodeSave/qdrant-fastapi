# Архитектура проекта

## Общая концепция

Проект построен на **доменной архитектуре** с принципом **"Thin Router, Thick Service"**. Это означает чёткое разделение ответственности между слоями.

## Трёхслойная архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                     ROUTER (Thin)                            │
│  • Валидация HTTP request (Pydantic)                        │
│  • Вызов service через Depends()                            │
│  • HTTP статус-коды                                         │
│  • НЕ содержит бизнес-логики                               │
└──────────────────────────┬──────────────────────────────────┘
                           │ Depends(get_qdrant_service)
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                  SERVICE (Business Logic)                    │
│  • ВСЯ бизнес-логика здесь                                  │
│  • Валидация бизнес-правил                                  │
│  • Оркестрация операций                                     │
│  • Выброс доменных исключений                               │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    CLIENT (Data Access)                      │
│  • Операции с Qdrant                                        │
│  • Возвращает данные или None                               │
│  • НИКАКОЙ бизнес-логики                                    │
│  • Singleton паттерн                                        │
└─────────────────────────────────────────────────────────────┘
```

## Структура доменов

```
src/
├── main.py                 # Application Factory, Lifespan
├── config.py               # Pydantic Settings
│
├── shared/                 # Общие компоненты (cross-cutting)
│   ├── __init__.py
│   ├── exceptions.py       # Базовые исключения
│   └── schemas.py          # Общие схемы
│
└── qdrant/                 # Домен Qdrant
    ├── __init__.py         # Экспорт router
    ├── constants.py        # Константы домена
    ├── schemas.py          # Pydantic DTOs
    ├── exceptions.py       # Доменные исключения
    ├── client.py           # Data Access Layer
    ├── service.py          # Business Logic Layer
    ├── router.py           # Presentation Layer
    └── dependencies.py     # FastAPI DI
```

## Описание слоёв

### 1. Router Layer (`router.py`)

**Ответственность:**
- Принимает HTTP запросы
- Валидирует входные данные через Pydantic
- Делегирует обработку в Service
- Возвращает HTTP ответы с правильными статусами

**Правила:**
- Никакой бизнес-логики
- Не обращается к Client напрямую
- Только вызов методов Service

```python
@router.post("/collections", status_code=status.HTTP_201_CREATED)
async def create_collection(
    data: CollectionCreate,
    service: QdrantServiceDep,
) -> CollectionInfo:
    return await service.create_collection(data)
```

### 2. Service Layer (`service.py`)

**Ответственность:**
- Содержит всю бизнес-логику
- Валидирует бизнес-правила
- Оркестрирует операции
- Выбрасывает доменные исключения

**Правила:**
- Не знает о HTTP (никаких HTTPException)
- Получает Client через DI
- Возвращает схемы или доменные объекты

```python
async def upsert_point(self, collection_name: str, point: PointCreate) -> PointResponse:
    # Бизнес-валидация
    collection_info = await self.get_collection(collection_name)

    if len(point.vector) != collection_info.vector_size:
        raise VectorSizeMismatchError(...)

    # Делегирование в Client
    await self.client.upsert_points(collection_name, [qdrant_point])

    return PointResponse(...)
```

### 3. Client Layer (`client.py`)

**Ответственность:**
- Операции с Qdrant
- Управление подключением (lifecycle)
- Health check
- Конвертация ошибок подключения

**Правила:**
- Singleton паттерн
- Никакой бизнес-логики
- Возвращает данные или выбрасывает ошибки подключения

```python
class QdrantClient:
    _instance: QdrantClient | None = None
    _client: AsyncQdrantClient | None = None

    def __new__(cls) -> QdrantClient:
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
```

## Dependency Injection

Цепочка зависимостей реализована через FastAPI `Depends`:

```
Request
    └── get_qdrant_service()
            └── get_qdrant_client()
                    └── qdrant_client (singleton)
```

### Использование

```python
# dependencies.py
QdrantServiceDep = Annotated[QdrantService, Depends(get_qdrant_service)]

# router.py
@router.get("/collections")
async def list_collections(service: QdrantServiceDep) -> CollectionListResponse:
    return await service.list_collections()
```

## Lifespan Management

Управление жизненным циклом приложения через `asynccontextmanager`:

```python
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    # STARTUP
    logger.info("Starting %s v%s", settings.project_name, settings.version)
    await qdrant_client.connect()

    yield

    # SHUTDOWN
    logger.info("Shutting down %s", settings.project_name)
    await qdrant_client.close()
```

## Exception Handling

Централизованная обработка исключений:

```
Service throws:    DomainError (NotFoundError, ValidationError, etc.)
                        │
                        ▼
main.py:           @app.exception_handler(DomainError)
                        │
                        ▼
HTTP Response:     JSONResponse(status_code=exc.status_code, ...)
```

### Иерархия исключений

```
DomainError (400)
├── NotFoundError (404)
├── AlreadyExistsError (409)
├── ValidationError (422)
└── ConnectionError (503)
```

## Пагинация и Response Schemas

### Паттерн именования схем

| Тип схемы | Назначение | Пример |
|-----------|------------|--------|
| `*Create` | POST body (обязательные поля) | `CollectionCreate` |
| `*Update` | PATCH body (все опционально) | `CollectionUpdate` |
| `*Response` | GET response (включает id) | `PointResponse` |
| `*Params` | Query parameters | `PaginationParams` |

### Пагинированный ответ

```python
class PaginatedResponse(BaseSchema, Generic[T]):
    items: list[T]
    total: int
    offset: int
    limit: int

    @property
    def has_more(self) -> bool:
        return self.offset + len(self.items) < self.total
```

## Паттерн Application Factory

```python
def create_application() -> FastAPI:
    app = FastAPI(
        title=settings.project_name,
        version=settings.version,
        lifespan=lifespan,
    )

    # Exception handlers
    @app.exception_handler(DomainError)
    async def domain_error_handler(...): ...

    # Routers
    app.include_router(qdrant_router, prefix=settings.api_prefix)

    return app

app = create_application()
```

## Диаграмма потока данных

```
HTTP Request
     │
     ▼
┌─────────────────┐     ┌─────────────────┐
│  Pydantic       │────▶│    Router       │
│  Validation     │     │  (HTTP Layer)   │
└─────────────────┘     └────────┬────────┘
                                 │
                                 ▼
                        ┌─────────────────┐
                        │    Service      │
                        │ (Business Logic)│
                        └────────┬────────┘
                                 │
                                 ▼
                        ┌─────────────────┐
                        │    Client       │
                        │ (Data Access)   │
                        └────────┬────────┘
                                 │
                                 ▼
                        ┌─────────────────┐
                        │    Qdrant       │
                        │   Database      │
                        └─────────────────┘
```

## Следующие разделы

- [Установка](03_установка.md) — как развернуть проект
- [Конфигурация](04_конфигурация.md) — настройки приложения
- [API Reference](05_api_reference.md) — описание endpoints
