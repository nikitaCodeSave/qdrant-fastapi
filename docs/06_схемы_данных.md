# Схемы данных (Pydantic Models)

## Обзор

Все схемы данных определены с использованием Pydantic v2. Схемы обеспечивают:

- Валидацию входных данных
- Сериализацию/десериализацию JSON
- Автогенерацию OpenAPI спецификации
- Type hints для IDE

## Паттерн именования

| Суффикс | Назначение | Пример |
|---------|------------|--------|
| `*Create` | POST body (обязательные поля) | `CollectionCreate` |
| `*Update` | PATCH body (все опционально) | `CollectionUpdate` |
| `*Response` | Response schema (включает id) | `PointResponse` |
| `*Params` | Query parameters | `PaginationParams` |
| `*Request` | Complex request body | `SearchRequest` |

---

## Базовые схемы

### QdrantBaseSchema

```python
class QdrantBaseSchema(BaseModel):
    """Базовая схема с общими настройками."""

    model_config = ConfigDict(
        from_attributes=True,    # Создание из ORM/dataclass
        populate_by_name=True,   # Поддержка alias
    )
```

### ErrorResponse

Стандартный формат ответа с ошибкой:

```python
class ErrorResponse(BaseModel):
    error: str      # Машиночитаемый код: "not_found"
    message: str    # Человекочитаемое описание
    details: dict | None = None
```

**Пример:**

```json
{
  "error": "collection_not_found",
  "message": "Collection 'docs' not found",
  "details": {"collection": "docs"}
}
```

---

## Collection Schemas

### CollectionCreate

Создание новой коллекции:

```python
class CollectionCreate(BaseModel):
    name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Имя коллекции",
        examples=["documents", "products"],
    )
    vector_size: int = Field(
        ...,
        ge=1,
        le=65536,
        description="Размерность векторов",
        examples=[1024, 1536],
    )
    distance: Literal["Cosine", "Euclid", "Dot"] = Field(
        default="Cosine",
        description="Метрика расстояния",
    )
    on_disk: bool = Field(
        default=False,
        description="Хранить векторы на диске",
    )
```

**Пример:**

```json
{
  "name": "documents",
  "vector_size": 1024,
  "distance": "Cosine",
  "on_disk": false
}
```

### CollectionInfo

Информация о коллекции:

```python
class CollectionInfo(QdrantBaseSchema):
    name: str
    vectors_count: int = Field(..., ge=0)
    points_count: int = Field(..., ge=0)
    status: str = Field(..., description="green | yellow | red")
    vector_size: int
    distance: str
```

**Пример:**

```json
{
  "name": "documents",
  "vectors_count": 1500,
  "points_count": 1500,
  "status": "green",
  "vector_size": 1024,
  "distance": "Cosine"
}
```

### CollectionListResponse

Список коллекций:

```python
class CollectionListResponse(BaseModel):
    collections: list[CollectionInfo]
    total: int = Field(..., ge=0)
```

---

## Point Schemas

### PointCreate

Создание точки (документа с вектором):

```python
class PointCreate(BaseModel):
    id: str | int = Field(
        ...,
        description="Уникальный ID точки"
    )
    vector: list[float] = Field(
        ...,
        min_length=1,
        description="Вектор embedding"
    )
    payload: dict[str, Any] = Field(
        default_factory=dict,
        description="Метаданные документа",
    )
```

**Пример:**

```json
{
  "id": "doc_123",
  "vector": [0.1, 0.2, 0.3, ...],
  "payload": {
    "text": "Содержимое документа...",
    "metadata": {"source": "manual.pdf"}
  }
}
```

### PointsBatchCreate

Batch создание точек:

```python
class PointsBatchCreate(BaseModel):
    points: list[PointCreate] = Field(
        ...,
        min_length=1,
        max_length=1000
    )
```

### PointResponse

Ответ с данными точки:

```python
class PointResponse(QdrantBaseSchema):
    id: str | int
    vector: list[float] | None = Field(
        default=None,
        description="Вектор (если запрошен)"
    )
    payload: dict[str, Any]
    score: float | None = Field(
        default=None,
        description="Score при поиске"
    )
```

---

## Search Schemas

### SearchRequest

Запрос векторного поиска:

```python
class SearchRequest(BaseModel):
    vector: list[float] = Field(
        ...,
        min_length=1,
        description="Вектор запроса"
    )
    limit: int = Field(
        default=10,
        ge=1,
        le=100,
        description="Количество результатов",
    )
    score_threshold: float | None = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="Минимальный score",
    )
    with_payload: bool = Field(
        default=True,
        description="Включить payload"
    )
    with_vector: bool = Field(
        default=False,
        description="Включить вектор"
    )
    filter: dict[str, Any] | None = Field(
        default=None,
        description="Фильтр по payload полям",
    )
```

**Пример:**

```json
{
  "vector": [0.1, 0.2, ...],
  "limit": 10,
  "score_threshold": 0.7,
  "with_payload": true,
  "filter": {"source": "manual.pdf"}
}
```

### SearchResult

Результат поиска:

```python
class SearchResult(QdrantBaseSchema):
    id: str | int
    score: float = Field(
        ...,
        description="Релевантность (0-1 для Cosine)"
    )
    payload: dict[str, Any] | None = None
    vector: list[float] | None = None
```

### SearchResponse

Ответ поиска:

```python
class SearchResponse(BaseModel):
    results: list[SearchResult]
    total: int = Field(..., ge=0, description="Количество найденных")
    limit: int
    query_time_ms: float | None = Field(
        default=None,
        description="Время выполнения"
    )
```

**Пример:**

```json
{
  "results": [
    {"id": "doc_123", "score": 0.95, "payload": {...}},
    {"id": "doc_456", "score": 0.87, "payload": {...}}
  ],
  "total": 2,
  "limit": 10,
  "query_time_ms": 3.45
}
```

---

## Document Schemas (высокоуровневые)

### DocumentCreate

Для случаев, когда embedding вычисляется на стороне сервиса:

```python
class DocumentCreate(BaseModel):
    id: str = Field(..., min_length=1)
    text: str = Field(
        ...,
        min_length=1,
        max_length=65536,
        description="Текст документа",
    )
    metadata: dict[str, Any] = Field(default_factory=dict)
```

### SearchByTextRequest

Поиск по тексту (требует embedding service):

```python
class SearchByTextRequest(BaseModel):
    text: str = Field(
        ...,
        min_length=1,
        max_length=65536,
        description="Текст запроса",
    )
    limit: int = Field(default=10, ge=1, le=100)
    score_threshold: float | None = Field(default=None, ge=0.0, le=1.0)
    filter: dict[str, Any] | None = None
```

---

## Shared Schemas

### PaginationParams

Query параметры пагинации:

```python
class PaginationParams(BaseModel):
    offset: int = Field(default=0, ge=0)
    limit: int = Field(default=20, ge=1, le=100)
```

### PaginatedResponse

Generic обёртка для списков:

```python
class PaginatedResponse(BaseSchema, Generic[T]):
    items: list[T]
    total: int = Field(..., ge=0)
    offset: int = Field(..., ge=0)
    limit: int = Field(..., ge=1)

    @property
    def has_more(self) -> bool:
        return self.offset + len(self.items) < self.total
```

### HealthResponse

Health check ответ:

```python
class ServiceHealth(BaseModel):
    status: str  # "healthy" | "unhealthy"
    latency_ms: float | None = None
    error: str | None = None

class HealthResponse(BaseModel):
    status: str  # "healthy" | "degraded" | "unhealthy"
    version: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    services: dict[str, ServiceHealth] = Field(default_factory=dict)
```

---

## Константы и лимиты

Определены в `src/qdrant/constants.py`:

```python
# Collection
MAX_COLLECTION_NAME_LENGTH = 255
MIN_COLLECTION_NAME_LENGTH = 1

# Vector
MIN_VECTOR_SIZE = 1
MAX_VECTOR_SIZE = 65536

# Search
DEFAULT_SEARCH_LIMIT = 10
MAX_SEARCH_LIMIT = 100

# Batch
DEFAULT_BATCH_SIZE = 100
MAX_BATCH_SIZE = 1000

# Payload
MAX_TEXT_FIELD_LENGTH = 65536
```

### Distance

```python
class Distance:
    COSINE = "Cosine"
    EUCLID = "Euclid"
    DOT = "Dot"
    ALL = (COSINE, EUCLID, DOT)
```

### PayloadFields

Стандартные имена полей:

```python
class PayloadFields:
    TEXT = "text"
    DOCUMENT_ID = "document_id"
    CHUNK_INDEX = "chunk_index"
    TOTAL_CHUNKS = "total_chunks"
    METADATA = "metadata"
    CREATED_AT = "created_at"
    FILE_HASH = "file_hash"
```

---

## Валидация

### Автоматическая валидация

Pydantic автоматически валидирует:

```python
# Ошибка: vector_size должен быть >= 1
CollectionCreate(name="test", vector_size=0)
# ValidationError: value is not a valid integer

# Ошибка: limit не может быть > 100
SearchRequest(vector=[...], limit=500)
# ValidationError: ensure this value is less than or equal to 100
```

### Кастомная валидация

Можно добавить validators:

```python
from pydantic import field_validator

class CollectionCreate(BaseModel):
    name: str

    @field_validator("name")
    @classmethod
    def name_must_not_be_reserved(cls, v: str) -> str:
        if v in ["system", "admin", "_internal"]:
            raise ValueError("Reserved collection name")
        return v
```

## Следующие разделы

- [Обработка ошибок](07_обработка_ошибок.md) — система исключений
- [Qdrant клиент](08_qdrant_клиент.md) — Data Access Layer
