# Обработка ошибок

## Философия

Проект использует **доменные исключения** вместо HTTP исключений в бизнес-логике. Это обеспечивает:

1. **Разделение ответственности**: Service не знает о HTTP
2. **Тестируемость**: исключения проще тестировать
3. **Консистентность**: единый формат ошибок

## Иерархия исключений

```
DomainError (400) ─── базовый класс
├── NotFoundError (404)
├── AlreadyExistsError (409)
├── ValidationError (422)
└── ConnectionError (503)
```

### Доменные исключения Qdrant

```
NotFoundError (404)
├── CollectionNotFoundError
└── PointNotFoundError

AlreadyExistsError (409)
├── CollectionAlreadyExistsError
└── PointAlreadyExistsError

ValidationError (422)
├── VectorSizeMismatchError
├── InvalidVectorError
└── InvalidFilterError

ConnectionError (503)
├── QdrantConnectionError
└── QdrantTimeoutError
```

---

## Базовые исключения

### DomainError

```python
class DomainError(Exception):
    """Базовое доменное исключение."""

    message: str = "Domain error occurred"
    error_code: str = "domain_error"
    status_code: int = 400

    def __init__(
        self,
        message: str | None = None,
        error_code: str | None = None,
        details: dict | None = None,
    ) -> None:
        self.message = message or self.__class__.message
        self.error_code = error_code or self.__class__.error_code
        self.details = details
        super().__init__(self.message)

    def to_dict(self) -> dict:
        result = {"error": self.error_code, "message": self.message}
        if self.details:
            result["details"] = self.details
        return result
```

### NotFoundError

```python
class NotFoundError(DomainError):
    """Ресурс не найден (HTTP 404)."""

    message = "Resource not found"
    error_code = "not_found"
    status_code = 404
```

### AlreadyExistsError

```python
class AlreadyExistsError(DomainError):
    """Ресурс уже существует (HTTP 409)."""

    message = "Resource already exists"
    error_code = "already_exists"
    status_code = 409
```

### ValidationError

```python
class ValidationError(DomainError):
    """Ошибка бизнес-валидации (HTTP 422)."""

    message = "Validation error"
    error_code = "validation_error"
    status_code = 422
```

### ConnectionError

```python
class ConnectionError(DomainError):
    """Ошибка подключения (HTTP 503)."""

    message = "Service connection error"
    error_code = "connection_error"
    status_code = 503
```

---

## Доменные исключения Qdrant

### Collections

```python
class CollectionNotFoundError(NotFoundError):
    """Коллекция не найдена."""
    message = "Collection not found"
    error_code = "collection_not_found"

class CollectionAlreadyExistsError(AlreadyExistsError):
    """Коллекция уже существует."""
    message = "Collection already exists"
    error_code = "collection_already_exists"
```

### Points

```python
class PointNotFoundError(NotFoundError):
    """Точка не найдена."""
    message = "Point not found"
    error_code = "point_not_found"

class PointAlreadyExistsError(AlreadyExistsError):
    """Точка уже существует."""
    message = "Point already exists"
    error_code = "point_already_exists"
```

### Validation

```python
class VectorSizeMismatchError(ValidationError):
    """Размерность вектора не соответствует."""
    message = "Vector size does not match collection configuration"
    error_code = "vector_size_mismatch"

class InvalidVectorError(ValidationError):
    """Некорректный вектор."""
    message = "Invalid vector data"
    error_code = "invalid_vector"

class InvalidFilterError(ValidationError):
    """Некорректный фильтр."""
    message = "Invalid filter expression"
    error_code = "invalid_filter"
```

### Connection

```python
class QdrantConnectionError(ConnectionError):
    """Ошибка подключения к Qdrant."""
    message = "Cannot connect to Qdrant"
    error_code = "qdrant_connection_error"

class QdrantTimeoutError(ConnectionError):
    """Таймаут операции."""
    message = "Qdrant operation timed out"
    error_code = "qdrant_timeout"
```

---

## Централизованный Exception Handler

В `main.py` определён глобальный обработчик:

```python
@app.exception_handler(DomainError)
async def domain_error_handler(request: Request, exc: DomainError) -> JSONResponse:
    """Конвертирует DomainError в HTTP ответ."""
    logger.warning(
        "DomainError: %s [%s] - %s",
        exc.error_code,
        exc.status_code,
        exc.message,
    )
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error=exc.error_code,
            message=exc.message,
            details=exc.details,
        ).model_dump(),
    )
```

---

## Формат ответа с ошибкой

Все ошибки возвращаются в едином формате:

```json
{
  "error": "error_code",
  "message": "Человекочитаемое описание",
  "details": {
    "key": "value"
  }
}
```

### Примеры

**404 - Collection Not Found:**

```json
{
  "error": "collection_not_found",
  "message": "Collection 'documents' not found",
  "details": {"collection": "documents"}
}
```

**409 - Collection Already Exists:**

```json
{
  "error": "collection_already_exists",
  "message": "Collection 'documents' already exists",
  "details": {"collection": "documents"}
}
```

**422 - Vector Size Mismatch:**

```json
{
  "error": "vector_size_mismatch",
  "message": "Expected 1024, got 512",
  "details": {"expected": 1024, "got": 512}
}
```

**503 - Connection Error:**

```json
{
  "error": "qdrant_connection_error",
  "message": "Cannot connect to Qdrant: Connection refused",
  "details": {"mode": "server"}
}
```

---

## Использование в Service

```python
class QdrantService:
    async def get_collection(self, name: str) -> CollectionInfo:
        """Получить коллекцию или выбросить исключение."""
        info = await self.client.get_collection_info(name)
        # Client выбросит CollectionNotFoundError если не найдено
        return CollectionInfo(...)

    async def upsert_point(
        self,
        collection_name: str,
        point: PointCreate,
    ) -> PointResponse:
        # Валидация бизнес-правил
        collection_info = await self.get_collection(collection_name)

        if len(point.vector) != collection_info.vector_size:
            raise VectorSizeMismatchError(
                f"Expected {collection_info.vector_size}, got {len(point.vector)}",
                details={
                    "expected": collection_info.vector_size,
                    "got": len(point.vector),
                },
            )

        # Продолжение логики...
```

---

## Использование в Client

```python
class QdrantClient:
    async def get_collection_info(self, name: str) -> models.CollectionInfo:
        """Получить информацию о коллекции."""
        if not await self.collection_exists(name):
            raise CollectionNotFoundError(
                f"Collection '{name}' not found",
                details={"collection": name},
            )
        return await self.client.get_collection(name)

    async def create_collection(self, name: str, ...) -> bool:
        """Создать коллекцию."""
        if await self.collection_exists(name):
            raise CollectionAlreadyExistsError(
                f"Collection '{name}' already exists",
                details={"collection": name},
            )
        # Создание...
```

---

## Pydantic Validation Errors

FastAPI автоматически обрабатывает ошибки валидации Pydantic и возвращает 422:

```json
{
  "detail": [
    {
      "type": "string_too_short",
      "loc": ["body", "name"],
      "msg": "String should have at least 1 character",
      "input": "",
      "ctx": {"min_length": 1}
    }
  ]
}
```

---

## Таблица HTTP кодов

| Код | Исключение | Описание |
|-----|------------|----------|
| 400 | `DomainError` | Общая ошибка домена |
| 404 | `NotFoundError` | Ресурс не найден |
| 409 | `AlreadyExistsError` | Ресурс уже существует |
| 422 | `ValidationError` | Ошибка бизнес-валидации |
| 422 | Pydantic | Ошибка валидации схемы |
| 503 | `ConnectionError` | Сервис недоступен |

---

## Логирование ошибок

Все DomainError логируются на уровне WARNING:

```
2025-01-01 12:00:00 | WARNING  | src.main | DomainError: collection_not_found [404] - Collection 'docs' not found
```

Критические ошибки (подключение) логируются на уровне ERROR:

```
2025-01-01 12:00:00 | ERROR    | src.qdrant.client | Failed to connect to Qdrant: Connection refused
```

---

## Расширение иерархии

Для добавления нового типа ошибки:

```python
# src/qdrant/exceptions.py
class RateLimitExceededError(DomainError):
    """Превышен лимит запросов."""
    message = "Rate limit exceeded"
    error_code = "rate_limit_exceeded"
    status_code = 429

# Использование
raise RateLimitExceededError(
    "Too many requests",
    details={"retry_after": 60}
)
```

## Следующие разделы

- [Qdrant клиент](08_qdrant_клиент.md) — работа с базой данных
- [Сервисный слой](09_сервисный_слой.md) — бизнес-логика
