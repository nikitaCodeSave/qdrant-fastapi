# Сервисный слой (Business Logic)

## Обзор

`QdrantService` содержит **всю бизнес-логику** домена Qdrant:

- Валидация бизнес-правил
- Оркестрация операций
- Преобразование данных
- Выброс доменных исключений

**Файл:** `src/qdrant/service.py`

## Принципы

1. **Толстый Service**: вся логика здесь, роутер тонкий
2. **Не знает о HTTP**: никаких HTTPException
3. **Получает Client через DI**: конструктор
4. **Возвращает Pydantic схемы**: не сырые объекты Qdrant

---

## Структура класса

```python
class QdrantService:
    """Сервис для работы с Qdrant."""

    def __init__(self, client: QdrantClient) -> None:
        """Client инжектируется через DI."""
        self.client = client

    # Collections
    async def list_collections(self) -> CollectionListResponse: ...
    async def get_collection(self, name: str) -> CollectionInfo: ...
    async def create_collection(self, data: CollectionCreate) -> CollectionInfo: ...
    async def delete_collection(self, name: str) -> bool: ...

    # Points
    async def upsert_point(self, collection_name: str, point: PointCreate) -> PointResponse: ...
    async def upsert_points_batch(self, collection_name: str, points: list[PointCreate]) -> int: ...
    async def get_point(self, collection_name: str, point_id: str | int, with_vector: bool = False) -> PointResponse: ...
    async def delete_point(self, collection_name: str, point_id: str | int) -> bool: ...

    # Search
    async def search(self, collection_name: str, request: SearchRequest) -> SearchResponse: ...

    # Health
    async def health_check(self) -> dict[str, Any]: ...
```

---

## Dependency Injection

Service получает Client через FastAPI Depends:

```python
# src/qdrant/dependencies.py
def get_qdrant_service(
    client: QdrantClient = Depends(get_qdrant_client),
) -> QdrantService:
    return QdrantService(client)

# Type alias для удобства
QdrantServiceDep = Annotated[QdrantService, Depends(get_qdrant_service)]

# Использование в роутере
@router.get("/collections")
async def list_collections(service: QdrantServiceDep) -> CollectionListResponse:
    return await service.list_collections()
```

---

## API методов

### Collections

#### list_collections

```python
async def list_collections(self) -> CollectionListResponse:
    """Получить список коллекций с информацией."""
    names = await self.client.list_collections()
    collections = []

    for name in names:
        try:
            info = await self.get_collection(name)
            collections.append(info)
        except CollectionNotFoundError:
            # Коллекция могла быть удалена между вызовами
            continue

    return CollectionListResponse(
        collections=collections,
        total=len(collections),
    )
```

#### get_collection

```python
async def get_collection(self, name: str) -> CollectionInfo:
    """Получить информацию о коллекции."""
    info = await self.client.get_collection_info(name)

    # Извлекаем параметры вектора
    vector_config = info.config.params.vectors
    if isinstance(vector_config, models.VectorParams):
        vector_size = vector_config.size
        distance = vector_config.distance.value
    else:
        # Named vectors — берём первый
        first_vector = next(iter(vector_config.values()))
        vector_size = first_vector.size
        distance = first_vector.distance.value

    return CollectionInfo(
        name=name,
        vectors_count=info.vectors_count or 0,
        points_count=info.points_count or 0,
        status=info.status.value,
        vector_size=vector_size,
        distance=distance,
    )
```

#### create_collection

```python
async def create_collection(self, data: CollectionCreate) -> CollectionInfo:
    """Создать новую коллекцию."""
    await self.client.create_collection(
        name=data.name,
        vector_size=data.vector_size,
        distance=data.distance,
        on_disk=data.on_disk,
    )
    return await self.get_collection(data.name)
```

#### delete_collection

```python
async def delete_collection(self, name: str) -> bool:
    """Удалить коллекцию."""
    return await self.client.delete_collection(name)
```

---

### Points

#### upsert_point

```python
async def upsert_point(
    self,
    collection_name: str,
    point: PointCreate,
) -> PointResponse:
    """Добавить или обновить точку."""
    # 1. Валидация: коллекция существует
    collection_info = await self.get_collection(collection_name)

    # 2. Валидация: размерность вектора
    if len(point.vector) != collection_info.vector_size:
        raise VectorSizeMismatchError(
            f"Expected {collection_info.vector_size}, got {len(point.vector)}",
            details={
                "expected": collection_info.vector_size,
                "got": len(point.vector),
            },
        )

    # 3. Upsert
    qdrant_point = models.PointStruct(
        id=point.id,
        vector=point.vector,
        payload=point.payload,
    )
    await self.client.upsert_points(collection_name, [qdrant_point])

    return PointResponse(
        id=point.id,
        vector=point.vector,
        payload=point.payload,
    )
```

#### upsert_points_batch

```python
async def upsert_points_batch(
    self,
    collection_name: str,
    points: list[PointCreate],
) -> int:
    """Batch upsert точек."""
    # Валидация коллекции
    collection_info = await self.get_collection(collection_name)

    # Валидация размерности для ВСЕХ точек
    for point in points:
        if len(point.vector) != collection_info.vector_size:
            raise VectorSizeMismatchError(
                f"Point {point.id}: expected {collection_info.vector_size}, got {len(point.vector)}",
            )

    # Конвертация в PointStruct
    qdrant_points = [
        models.PointStruct(
            id=p.id,
            vector=p.vector,
            payload=p.payload,
        )
        for p in points
    ]

    return await self.client.upsert_points(collection_name, qdrant_points)
```

#### get_point

```python
async def get_point(
    self,
    collection_name: str,
    point_id: str | int,
    with_vector: bool = False,
) -> PointResponse:
    """Получить точку по ID."""
    record = await self.client.get_point(
        collection_name,
        point_id,
        with_vector=with_vector,
    )

    if record is None:
        raise PointNotFoundError(
            f"Point '{point_id}' not found",
            details={"point_id": point_id, "collection": collection_name},
        )

    return PointResponse(
        id=record.id,
        vector=record.vector if with_vector else None,
        payload=record.payload or {},
    )
```

#### delete_point

```python
async def delete_point(self, collection_name: str, point_id: str | int) -> bool:
    """Удалить точку."""
    # Проверяем существование
    await self.get_point(collection_name, point_id)
    await self.client.delete_points(collection_name, [point_id])
    return True
```

---

### Search

```python
async def search(
    self,
    collection_name: str,
    request: SearchRequest,
) -> SearchResponse:
    """Векторный поиск."""
    # 1. Валидация коллекции и размерности
    collection_info = await self.get_collection(collection_name)

    if len(request.vector) != collection_info.vector_size:
        raise VectorSizeMismatchError(
            f"Query vector: expected {collection_info.vector_size}, got {len(request.vector)}",
        )

    # 2. Поиск с замером времени
    start = time.perf_counter()

    scored_points = await self.client.search(
        collection_name=collection_name,
        vector=request.vector,
        limit=request.limit,
        score_threshold=request.score_threshold,
        filter_=request.filter,
        with_payload=request.with_payload,
        with_vector=request.with_vector,
    )

    query_time = (time.perf_counter() - start) * 1000

    # 3. Конвертация результатов
    results = [
        SearchResult(
            id=point.id,
            score=point.score,
            payload=point.payload if request.with_payload else None,
            vector=point.vector if request.with_vector else None,
        )
        for point in scored_points
    ]

    return SearchResponse(
        results=results,
        total=len(results),
        limit=request.limit,
        query_time_ms=round(query_time, 2),
    )
```

---

## Паттерны и практики

### Валидация бизнес-правил

Service проверяет правила, которые нельзя выразить в Pydantic:

```python
# Размерность вектора должна соответствовать коллекции
if len(point.vector) != collection_info.vector_size:
    raise VectorSizeMismatchError(...)

# Ресурс должен существовать
record = await self.client.get_point(...)
if record is None:
    raise PointNotFoundError(...)
```

### Преобразование данных

Service конвертирует внутренние объекты Qdrant в Pydantic схемы:

```python
# Qdrant models.Record -> PointResponse
return PointResponse(
    id=record.id,
    vector=record.vector if with_vector else None,
    payload=record.payload or {},
)

# Qdrant models.ScoredPoint -> SearchResult
results = [
    SearchResult(
        id=point.id,
        score=point.score,
        payload=point.payload,
    )
    for point in scored_points
]
```

### Оркестрация операций

Service может комбинировать несколько вызовов Client:

```python
async def upsert_point(self, ...):
    # 1. Получить информацию о коллекции
    collection_info = await self.get_collection(collection_name)

    # 2. Валидация на основе информации
    if len(point.vector) != collection_info.vector_size:
        raise ...

    # 3. Выполнить upsert
    await self.client.upsert_points(...)
```

---

## Отличие от Client

| Аспект | Client | Service |
|--------|--------|---------|
| Ответственность | Data Access | Business Logic |
| Бизнес-логика | Нет | Да |
| Валидация | Только существование | Все бизнес-правила |
| Возвращает | Qdrant models или None | Pydantic schemas |
| Исключения | Connection errors, Not Found | + Validation errors |

---

## Расширение функциональности

Пример добавления метода поиска по тексту:

```python
class QdrantService:
    def __init__(
        self,
        client: QdrantClient,
        embedding_service: EmbeddingService | None = None,
    ) -> None:
        self.client = client
        self.embedding_service = embedding_service

    async def search_by_text(
        self,
        collection_name: str,
        request: SearchByTextRequest,
    ) -> SearchResponse:
        """Поиск по тексту (конвертирует в вектор)."""
        if self.embedding_service is None:
            raise ValidationError("Embedding service not configured")

        # Конвертация текста в вектор
        vector = await self.embedding_service.embed(request.text)

        # Делегирование в обычный поиск
        search_request = SearchRequest(
            vector=vector,
            limit=request.limit,
            score_threshold=request.score_threshold,
            filter=request.filter,
        )
        return await self.search(collection_name, search_request)
```

## Следующие разделы

- [Тестирование](10_тестирование.md) — как тестировать
- [Развертывание](11_развертывание.md) — деплой в production
