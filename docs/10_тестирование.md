# Тестирование

## Обзор

Проект использует **pytest** с async поддержкой для тестирования. Тесты изолированы от реального Qdrant через mock-объекты.

**Директория тестов:** `tests/`

## Структура тестов

```
tests/
├── __init__.py
├── conftest.py           # Общие фикстуры
└── qdrant/
    ├── __init__.py
    └── test_router.py    # Тесты API endpoints
```

---

## Установка зависимостей для тестов

```bash
pip install pytest pytest-asyncio pytest-cov httpx
```

---

## Запуск тестов

### Все тесты

```bash
pytest
```

### С подробным выводом

```bash
pytest -v
```

### С покрытием кода

```bash
pytest --cov=src --cov-report=html
```

Отчёт будет в `htmlcov/index.html`

### Конкретный файл/тест

```bash
# Файл
pytest tests/qdrant/test_router.py

# Класс
pytest tests/qdrant/test_router.py::TestHealthEndpoint

# Метод
pytest tests/qdrant/test_router.py::TestHealthEndpoint::test_health_returns_200
```

### С маркерами

```bash
# Только быстрые тесты
pytest -m "not slow"

# Только интеграционные
pytest -m integration
```

---

## Фикстуры (conftest.py)

### test_settings

```python
@pytest.fixture
def test_settings() -> Settings:
    """Тестовые настройки."""
    return Settings(
        project_name="Test Service",
        environment="development",
        qdrant_local_path="./test_qdrant_storage",
    )
```

### mock_qdrant_client

```python
@pytest.fixture
def mock_qdrant_client() -> MagicMock:
    """Mock Qdrant клиент."""
    mock = MagicMock(spec=QdrantClient)

    # Health check
    mock.health_check = AsyncMock(
        return_value={
            "status": "healthy",
            "latency_ms": 1.5,
            "collections_count": 0,
        }
    )

    # Collections
    mock.list_collections = AsyncMock(return_value=[])
    mock.collection_exists = AsyncMock(return_value=False)
    mock.create_collection = AsyncMock(return_value=True)
    mock.delete_collection = AsyncMock(return_value=True)

    # Points
    mock.upsert_points = AsyncMock(return_value=1)
    mock.get_point = AsyncMock(return_value=None)
    mock.delete_points = AsyncMock(return_value=1)

    # Search
    mock.search = AsyncMock(return_value=[])

    return mock
```

### client (AsyncClient)

```python
@pytest.fixture
async def client(mock_qdrant_client: MagicMock) -> AsyncGenerator[AsyncClient, None]:
    """Async HTTP клиент для тестирования API."""
    # Override dependencies
    app.dependency_overrides[get_qdrant_client] = lambda: mock_qdrant_client

    async with AsyncClient(
        transport=ASGITransport(app=app),
        base_url="http://test",
    ) as ac:
        yield ac

    # Cleanup
    app.dependency_overrides.clear()
```

### sample_vector

```python
@pytest.fixture
def sample_vector() -> list[float]:
    """Пример вектора размерности 1024."""
    return [0.1] * 1024
```

### sample_point

```python
@pytest.fixture
def sample_point(sample_vector: list[float]) -> dict:
    """Пример точки для тестов."""
    return {
        "id": "test_point_1",
        "vector": sample_vector,
        "payload": {
            "text": "Test document content",
            "metadata": {"source": "test"},
        },
    }
```

### sample_collection_create

```python
@pytest.fixture
def sample_collection_create() -> dict:
    """Пример данных для создания коллекции."""
    return {
        "name": "test_collection",
        "vector_size": 1024,
        "distance": "Cosine",
    }
```

---

## Примеры тестов

### Health Endpoint

```python
class TestHealthEndpoint:
    """Тесты health check."""

    async def test_health_returns_200(self, client: AsyncClient) -> None:
        """Health endpoint возвращает 200."""
        response = await client.get("/health")

        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "healthy"
        assert "qdrant" in data["services"]
```

### Collections Endpoints

```python
class TestCollectionsEndpoints:
    """Тесты endpoints коллекций."""

    async def test_list_collections_empty(self, client: AsyncClient) -> None:
        """Пустой список коллекций."""
        response = await client.get("/api/v1/qdrant/collections")

        assert response.status_code == 200
        data = response.json()
        assert data["collections"] == []
        assert data["total"] == 0

    async def test_create_collection_success(
        self,
        client: AsyncClient,
        sample_collection_create: dict,
        mock_qdrant_client,
    ) -> None:
        """Успешное создание коллекции."""
        # Настраиваем mock
        from qdrant_client import models

        mock_info = models.CollectionInfo(
            status=models.CollectionStatus.GREEN,
            vectors_count=0,
            points_count=0,
            config=models.CollectionConfig(
                params=models.CollectionParams(
                    vectors=models.VectorParams(
                        size=1024,
                        distance=models.Distance.COSINE,
                    ),
                ),
            ),
        )
        mock_qdrant_client.get_collection_info.return_value = mock_info
        mock_qdrant_client.collection_exists.return_value = False

        response = await client.post(
            "/api/v1/qdrant/collections",
            json=sample_collection_create,
        )

        assert response.status_code == 201
        data = response.json()
        assert data["name"] == sample_collection_create["name"]

    async def test_create_collection_validation_error(
        self,
        client: AsyncClient,
    ) -> None:
        """Ошибка валидации при создании коллекции."""
        response = await client.post(
            "/api/v1/qdrant/collections",
            json={"name": "", "vector_size": 0},  # Невалидные данные
        )

        assert response.status_code == 422
```

### Search Endpoints

```python
class TestSearchEndpoints:
    """Тесты endpoints поиска."""

    async def test_search_validation_error(
        self,
        client: AsyncClient,
    ) -> None:
        """Ошибка валидации при поиске."""
        response = await client.post(
            "/api/v1/qdrant/collections/test/search",
            json={"vector": []},  # Пустой вектор
        )

        assert response.status_code == 422
```

---

## Тестирование Service

```python
import pytest
from unittest.mock import AsyncMock, MagicMock

from src.qdrant.service import QdrantService
from src.qdrant.exceptions import VectorSizeMismatchError

class TestQdrantService:
    @pytest.fixture
    def mock_client(self) -> MagicMock:
        return MagicMock()

    @pytest.fixture
    def service(self, mock_client: MagicMock) -> QdrantService:
        return QdrantService(mock_client)

    async def test_upsert_point_vector_size_mismatch(
        self,
        service: QdrantService,
        mock_client: MagicMock,
    ) -> None:
        """Ошибка при несовпадении размерности."""
        # Mock get_collection возвращает коллекцию с vector_size=1024
        mock_client.get_collection_info = AsyncMock(...)

        point = PointCreate(
            id="test",
            vector=[0.1] * 512,  # Неправильная размерность
            payload={},
        )

        with pytest.raises(VectorSizeMismatchError):
            await service.upsert_point("test_collection", point)
```

---

## Тестирование с реальным Qdrant

Для интеграционных тестов можно использовать реальный Qdrant:

```python
import pytest

@pytest.fixture(scope="session")
async def real_qdrant_client():
    """Реальный клиент для интеграционных тестов."""
    from src.qdrant.client import QdrantClient

    client = QdrantClient()
    await client.connect()
    yield client
    await client.close()

@pytest.mark.integration
async def test_create_and_delete_collection(real_qdrant_client):
    """Интеграционный тест создания коллекции."""
    name = "test_integration_collection"

    # Создаём
    await real_qdrant_client.create_collection(
        name=name,
        vector_size=128,
        distance="Cosine",
    )

    # Проверяем
    assert await real_qdrant_client.collection_exists(name)

    # Удаляем
    await real_qdrant_client.delete_collection(name)
    assert not await real_qdrant_client.collection_exists(name)
```

---

## Конфигурация pytest

### pyproject.toml

```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
markers = [
    "slow: marks tests as slow",
    "integration: marks tests as integration tests",
]
```

### pytest.ini (альтернатива)

```ini
[pytest]
asyncio_mode = auto
testpaths = tests
markers =
    slow: marks tests as slow
    integration: marks tests as integration tests
```

---

## Покрытие кода

### Генерация отчёта

```bash
pytest --cov=src --cov-report=html --cov-report=term-missing
```

### Минимальное покрытие

```bash
pytest --cov=src --cov-fail-under=80
```

---

## CI/CD Integration

### GitHub Actions пример

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-cov httpx

      - name: Run tests
        run: pytest --cov=src --cov-report=xml

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
```

## Следующие разделы

- [Развертывание](11_развертывание.md) — деплой в production
