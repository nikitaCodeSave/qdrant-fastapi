# Развертывание (Production Deployment)

## Обзор

Данный раздел описывает рекомендации по развертыванию Qdrant RAG Service в production окружении.

---

## Подготовка к production

### 1. Настройка конфигурации

```env
# .env.production
ENVIRONMENT=production
PROJECT_NAME="Qdrant RAG Service"
VERSION="0.1.0"

# API
API_PREFIX="/api/v1"

# Qdrant
QDRANT_HOST=qdrant.internal
QDRANT_PORT=6333
QDRANT_GRPC_PORT=6334
QDRANT_API_KEY=your-secure-api-key
QDRANT_PREFER_GRPC=true
QDRANT_TIMEOUT=60.0
QDRANT_HTTPS=true
```

### 2. Production checklist

- [ ] `ENVIRONMENT=production`
- [ ] `QDRANT_API_KEY` установлен
- [ ] `QDRANT_HTTPS=true` для remote Qdrant
- [ ] `.env` не в git репозитории
- [ ] Swagger UI отключен (автоматически в production)
- [ ] Логирование настроено (INFO level)

---

## Docker

### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Системные зависимости
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Зависимости Python
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Код приложения
COPY src/ ./src/

# Healthcheck
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Non-root user
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### .dockerignore

```
.git
.gitignore
.env
.env.*
__pycache__
*.pyc
*.pyo
.pytest_cache
.coverage
htmlcov
.venv
venv
*.md
tests/
docs/
qdrant_storage/
```

### Build и запуск

```bash
# Build
docker build -t qdrant-service:latest .

# Run
docker run -d \
  --name qdrant-service \
  -p 8000:8000 \
  -e ENVIRONMENT=production \
  -e QDRANT_HOST=qdrant.internal \
  -e QDRANT_API_KEY=your-key \
  qdrant-service:latest
```

---

## Docker Compose (Production)

```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - qdrant_data:/qdrant/storage
    environment:
      - QDRANT__SERVICE__GRPC_PORT=6334
      - QDRANT__SERVICE__API_KEY=${QDRANT_API_KEY}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - ENVIRONMENT=production
      - QDRANT_HOST=qdrant
      - QDRANT_PORT=6333
      - QDRANT_API_KEY=${QDRANT_API_KEY}
      - QDRANT_PREFER_GRPC=true
    depends_on:
      qdrant:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  qdrant_data:
```

### Запуск

```bash
# С env файлом
docker-compose -f docker-compose.prod.yml --env-file .env.production up -d

# Просмотр логов
docker-compose -f docker-compose.prod.yml logs -f app
```

---

## Kubernetes

### Deployment

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: qdrant-service
  labels:
    app: qdrant-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: qdrant-service
  template:
    metadata:
      labels:
        app: qdrant-service
    spec:
      containers:
        - name: qdrant-service
          image: your-registry/qdrant-service:latest
          ports:
            - containerPort: 8000
          env:
            - name: ENVIRONMENT
              value: "production"
            - name: QDRANT_HOST
              value: "qdrant-service.qdrant.svc.cluster.local"
            - name: QDRANT_API_KEY
              valueFrom:
                secretKeyRef:
                  name: qdrant-secrets
                  key: api-key
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
```

### Service

```yaml
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: qdrant-service
spec:
  selector:
    app: qdrant-service
  ports:
    - port: 80
      targetPort: 8000
  type: ClusterIP
```

### Ingress

```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: qdrant-service-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
    - host: api.example.com
      http:
        paths:
          - path: /qdrant
            pathType: Prefix
            backend:
              service:
                name: qdrant-service
                port:
                  number: 80
```

---

## Gunicorn (Production Server)

### Конфигурация

```python
# gunicorn.conf.py
import multiprocessing

# Bind
bind = "0.0.0.0:8000"

# Workers
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "uvicorn.workers.UvicornWorker"

# Timeout
timeout = 120
graceful_timeout = 30
keepalive = 5

# Logging
accesslog = "-"
errorlog = "-"
loglevel = "info"

# Process naming
proc_name = "qdrant-service"

# Server mechanics
daemon = False
pidfile = None
umask = 0
user = None
group = None
tmp_upload_dir = None
```

### Запуск

```bash
gunicorn src.main:app -c gunicorn.conf.py
```

---

## Nginx (Reverse Proxy)

```nginx
# /etc/nginx/conf.d/qdrant-service.conf
upstream qdrant_service {
    server 127.0.0.1:8000;
    keepalive 32;
}

server {
    listen 80;
    server_name api.example.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.example.com;

    ssl_certificate /etc/letsencrypt/live/api.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.example.com/privkey.pem;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    location / {
        proxy_pass http://qdrant_service;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Health check (не логируем)
    location /health {
        proxy_pass http://qdrant_service/health;
        access_log off;
    }
}
```

---

## Systemd Service

```ini
# /etc/systemd/system/qdrant-service.service
[Unit]
Description=Qdrant RAG Service
After=network.target

[Service]
Type=simple
User=appuser
Group=appuser
WorkingDirectory=/opt/qdrant-service
Environment="PATH=/opt/qdrant-service/.venv/bin"
EnvironmentFile=/opt/qdrant-service/.env
ExecStart=/opt/qdrant-service/.venv/bin/gunicorn src.main:app -c gunicorn.conf.py
ExecReload=/bin/kill -s HUP $MAINPID
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

### Управление

```bash
# Включить автозапуск
sudo systemctl enable qdrant-service

# Запустить
sudo systemctl start qdrant-service

# Статус
sudo systemctl status qdrant-service

# Просмотр логов
sudo journalctl -u qdrant-service -f
```

---

## Мониторинг

### Prometheus Metrics

Добавьте middleware для метрик:

```python
# src/middleware/metrics.py
from prometheus_client import Counter, Histogram
from starlette.middleware.base import BaseHTTPMiddleware

REQUEST_COUNT = Counter(
    "http_requests_total",
    "Total HTTP requests",
    ["method", "endpoint", "status"]
)

REQUEST_LATENCY = Histogram(
    "http_request_duration_seconds",
    "HTTP request latency",
    ["method", "endpoint"]
)

class MetricsMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        start = time.time()
        response = await call_next(request)
        duration = time.time() - start

        REQUEST_COUNT.labels(
            method=request.method,
            endpoint=request.url.path,
            status=response.status_code
        ).inc()

        REQUEST_LATENCY.labels(
            method=request.method,
            endpoint=request.url.path
        ).observe(duration)

        return response
```

### Health Check Endpoint

Уже реализован: `GET /health`

---

## Логирование

### Structured Logging

```python
# src/logging_config.py
import json
import logging
import sys

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_obj = {
            "timestamp": self.formatTime(record),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }
        if record.exc_info:
            log_obj["exception"] = self.formatException(record.exc_info)
        return json.dumps(log_obj)

def setup_logging():
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(JSONFormatter())
    logging.root.handlers = [handler]
    logging.root.setLevel(logging.INFO)
```

---

## Безопасность

### CORS (если нужен)

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://your-frontend.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "DELETE"],
    allow_headers=["*"],
)
```

### Rate Limiting

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@router.post("/search")
@limiter.limit("100/minute")
async def search(...):
    ...
```

---

## Checklist перед деплоем

- [ ] Тесты проходят
- [ ] `ENVIRONMENT=production`
- [ ] Секреты через environment variables
- [ ] Health check настроен
- [ ] Логирование настроено
- [ ] SSL/TLS настроен
- [ ] Reverse proxy настроен
- [ ] Мониторинг настроен
- [ ] Backup стратегия для Qdrant data

---

## Qdrant Cloud

Альтернатива self-hosted:

1. Создайте кластер на https://cloud.qdrant.io
2. Получите API ключ и URL
3. Настройте переменные:

```env
QDRANT_HOST=your-cluster.cloud.qdrant.io
QDRANT_PORT=6333
QDRANT_API_KEY=your-cloud-api-key
QDRANT_HTTPS=true
```

---

## Полезные ссылки

- [Qdrant Documentation](https://qdrant.tech/documentation/)
- [FastAPI Deployment](https://fastapi.tiangolo.com/deployment/)
- [Gunicorn Configuration](https://docs.gunicorn.org/en/stable/configure.html)
- [Docker Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
